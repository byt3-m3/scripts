#!/usr/bin/env python
# encoding: utf-8
# Implementation of the work flow explained here: http://superuser.com/a/717689
# In short: Uses the database from cdcat to copy wanted files.

# modules {{{
import gzip, os, sys, logging
import xml.etree.ElementTree as ET
# }}}

class CdcatDatabase: # {{{
    def __init__(self, formats=[ 'git-annex' ], directory_separator = os.path.sep):
        self._directory_separator = directory_separator
        self._generate_formats = formats

    def parse_gzip_file(self, gzip_file):
        f = gzip.open(gzip_file, 'rb')
        tree = ET.ElementTree(ET.fromstring(f.read()))
        f.close()
        catalog = tree.getroot()
        self._for_catalog(catalog)

    def parse_uncompressed_xml_file(self, xml_file):
        tree = ET.parse(xml_file)
        catalog = tree.getroot()
        self._for_catalog(catalog)

    def _for_catalog(self, catalog):
        logging.info(u'Parsing catalog called "%s" owned by "%s" â€¦' % (catalog.attrib['name'], catalog.attrib['owner']))
        for media in catalog.findall('media'):
            logging.info(u'Parsing media: %s' % media.attrib['name'])
            self._for_dir(media, base_path, '', None)


    # helper functions {{{
    def _copy_node(self, node):
        category = node.find('category')
        if category is not None:
            is_number = True
            try:
                i = int(category.text)
            except ValueError:
                is_number = False
            return is_number
        else:
            return None

    def _get_path(self, cur_path, node):
        if cur_path is '':
            return node.attrib['name']
        return self._directory_separator.join([cur_path, node.attrib['name']])
    # }}}

    # generate copy script entry for node {{{
    def _add_to_copy_list(self, base_path, cur_path, file_path, unwanted, node_type):
        unwanted = [item for item in unwanted if item is not None]
        node_path = cur_path if node_type is 'dir' else file_path
        source_node_path = self._directory_separator.join([base_path, node_path])
        logging.debug(u'Include %s %s' % (node_type, node_type))
        if 'git-annex' in self._generate_formats:
            unwanted = ['--exclude=\'%s\'' % item for item in unwanted]
            # print 'mkdir -p \'%s\' && pushd \'%s\'' % (cur_path, cur_path)
            # print 'git annex get \'%s\' %s' % (source_node_path, ' '.join(unwanted))
            print 'git annex get \'%s\' %s' % (node_path, ' '.join(unwanted))
            # print 'popd'
    # }}}

    # for file {{{
    def _for_file(self, file_node, base_path, cur_path, implicit_wanted_node):
        file_path = self._get_path(cur_path, file_node)

        explicit_wanted_node = self._copy_node(file_node)
        wanted_node = explicit_wanted_node if explicit_wanted_node is not None else implicit_wanted_node

        if wanted_node is False:
            # if explicit_wanted_node is False and implicit_wanted_node is True:
            #     return file_path
            logging.debug(u'Not file %s' % file_path)
            return file_path
        elif wanted_node is True:
            if explicit_wanted_node is True and implicit_wanted_node is not True:
                self._add_to_copy_list(base_path, cur_path, file_path, [], 'file')
            else:
                # File is already included from a upper directory.
                return None
    # }}}

    # for dir {{{
    def _for_dir(self, dir_node, base_path, cur_path, implicit_wanted_node):
        cur_path = self._get_path(cur_path, dir_node)
        explicit_wanted_node = self._copy_node(dir_node)
        if implicit_wanted_node is False and explicit_wanted_node is not True:
            logging.debug(u'Not dir %s (excluded from upper dir)' % cur_path)
            return cur_path

        wanted_node = explicit_wanted_node if explicit_wanted_node is not None else implicit_wanted_node
        unwanted = []
        for directory_node in dir_node.findall('directory'):
            unwanted.append(self._for_dir(directory_node, base_path, cur_path, wanted_node))
        for file_node in dir_node.findall('file'):
            unwanted.append(self._for_file(file_node, base_path, cur_path, wanted_node))
        if wanted_node is True:
            self._add_to_copy_list(base_path, cur_path, None, unwanted, 'dir')
        if explicit_wanted_node is False:
            return cur_path
    # }}}
# }}}

# main {{{
def main(catalog_file, base_path):
    cdcat_db_object = CdcatDatabase()
    cdcat_db_object.parse_gzip_file(catalog_file)

if __name__ == '__main__':
    logging.basicConfig(
        format='# %(levelname)s: %(message)s',
        # level=logging.DEBUG,
        level=logging.INFO,
        )
    print '#!/bin/bash'
    logging.info(u'Running cdcat-parser: https://github.com/ypid/scripts/blob/master/cdcat-parser/cdcat-parser')
    if len(sys.argv) > 2:
        catalog_file = sys.argv[1]
        base_path = sys.argv[2]
    else:
        logging.error('Not enough parameters.'
                + ' 1. File path to catalog file.'
                + ' 2. Base path for the original media.'
                + ' Your current working directory will be the root of the target.'
                )
        sys.exit(1)
    main(catalog_file, base_path)
# }}}
